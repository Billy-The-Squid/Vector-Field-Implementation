#pragma kernel OutwardsField
#pragma kernel SwirlField
#pragma kernel CoulombField


// The buffer storing the positions
RWStructuredBuffer<float3> _Positions;

// The buffer storing the value of the vector field at each point
RWStructuredBuffer<float3> _Vectors;
// It's set every frame by the C# script.

// The (0,0,0) point of the field
float3 _CenterPosition;

// This buffer allows you to send additional vector arguments to whatever your field function is. 
RWStructuredBuffer<float> _FloatArgs;
RWStructuredBuffer<float3> _VectorArgs;
// It's up to you to parse these inside the function, so you can split them into two separate arrays
// if you choose. Just remember that not every model supports GetDimensions, so you need to figure
// out for yourself how to stop from going out of bounds. 




#include "FieldLibrary.hlsl"




//float CalculateMagnitudes(float index) {
//    float3 vect = _Vectors[index];
//    float vect_mag = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
//    _Magnitudes[index] = vect_mag;
//    return vect_mag;
//}



//float Rescale(float vect_mag) {
//	// Renormalizing...
//    return _MaxVectorLength * (1 - 1 / pow(vect_mag + 1, 2)) / (vect_mag + 0.000000001);
//};



//void FieldStrength(float index, FieldInterface field)
//{
//    float3 result = 0;
//    float3 position = _Positions[index];
//	result = field.Field(position - _CenterPosition);
//    _Vectors[index] = result;
//    //float res_mag = CalculateMagnitudes(index);
//    //result *= Rescale(res_mag);
//    //_PlotVectors[index] = result;
//};



//void CalcVectors23(float index)
//{ // Calculates the orthogonal vectors, given a vector.
//	// The other two unit vectors should be orthogonal to the first and have the same magnitude scaling.
//	// Please find a different way to do this. 
//    float3 vect = _PlotVectors[index];
//    float vect_mag = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
//    float3 vect_2;
//    float3 vect_3;
//    if (vect.x == 0.0 && vect.y == 0.0 && vect.z == 0.0)
//    { // Check whether we should just make the mesh disappear. 
//        _Vectors2[index] = float3(0.0, 0.0, 0.0);
//        _Vectors3[index] = float3(0.0, 0.0, 0.0);
//        return;
//    }
	
//	// Depending on how the material works and if the trans. matrix needs to scale, NORMALIZE VECT HERE.
//    if ((vect.x == 0.0) && (vect.y == 0.0))
//    { // Guaranteeing that vect_2 isn't parallel with vect with 
//        vect_2.x = 0.0;
//        vect_2.y = -vect.z;
//        vect_2.z = vect.y;
//    }
//    else
//    {
//        vect_2.x = vect.y;
//        vect_2.y = -vect.x;
//        vect_2.z = 0.0;
//    }

//	// Re-magnituding vect_2
//    float vect_2_mag = sqrt(vect_2.x * vect_2.x + vect_2.y * vect_2.y + vect_2.z * vect_2.z);
//    vect_2 *= (vect_mag / vect_2_mag);

//	// Cross product!
//    vect_3.x = vect.y * vect_2.z - vect.z * vect_2.y;
//    vect_3.y = vect.z * vect_2.x - vect.x * vect_2.z;
//    vect_3.z = vect.x * vect_2.y - vect.y * vect_2.x;

//	// Re-magnituding vect_3
//    float vect_3_mag = sqrt(vect_3.x * vect_3.x + vect_3.y * vect_3.y + vect_3.z * vect_3.z);
//    vect_3 *= (vect_mag / vect_3_mag);
	
//    _Vectors2[index] = vect_2;
//    _Vectors3[index] = vect_3;
//};


#define KERNEL_NAME(fieldName) \
    [numthreads(64, 1, 1)] \
    void fieldName##Field(uint3 id : SV_DispatchThreadID) { \
        uint bufferSize; \
        uint stride; \
        _Positions.GetDimensions(bufferSize, stride); \
        if (id.x < bufferSize) { \
            _Vectors[id.x] = fieldName(_Positions[id.x] - _CenterPosition); \
        } \
    }

KERNEL_NAME(Outwards)
KERNEL_NAME(Swirl)
KERNEL_NAME(Coulomb)