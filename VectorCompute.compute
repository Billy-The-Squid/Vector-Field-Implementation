#pragma kernel OutwardsField
#pragma kernel SwirlField

// The buffer storing the positions
RWStructuredBuffer<float3> _Positions;

// The buffer storing the value of the vector field at each point
RWStructuredBuffer<float3> _Vectors;
// It's set every frame by the C# script.

// The rescaled version of the vector field
RWStructuredBuffer<float3> _PlotVectors;
// Buffers that store the other coordinate axes
RWStructuredBuffer<float3> _Vectors2;
RWStructuredBuffer<float3> _Vectors3;
// Magnitudes
RWStructuredBuffer<float> _Magnitudes;

// The (0,0,0) point of the field
float3 _CenterPosition;

// maximum length a displayed vector can have
float _MaxVectorLength;




#include "FieldLibrary.hlsl"




float CalculateMagnitudes(float index) {
    float3 vect = _Vectors[index];
    float vect_mag = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
    _Magnitudes[index] = vect_mag;
    return vect_mag;
}



float Rescale(float vect_mag) {
	// Renormalizing...
    return _MaxVectorLength * (1 - 1 / pow(vect_mag + 1, 2)) / (vect_mag + 0.000000001);
};



void FieldStrength(float index, FieldInterface field)
{
    float3 result = 0;
    float3 position = _Positions[index];
	result = field.Field(position - _CenterPosition);
    _Vectors[index] = result;
    float res_mag = CalculateMagnitudes(index);
    result *= Rescale(res_mag);
    _PlotVectors[index] = result;
};



void CalcVectors23(float index)
{ // Calculates the orthogonal vectors, given a vector.
	// The other two unit vectors should be orthogonal to the first and have the same magnitude scaling.
	// Please find a different way to do this. 
    float3 vect = _PlotVectors[index];
    float vect_mag = sqrt(vect.x * vect.x + vect.y * vect.y + vect.z * vect.z);
    float3 vect_2;
    float3 vect_3;
    if (vect.x == 0.0 && vect.y == 0.0 && vect.z == 0.0)
    { // Check whether we should just make the mesh disappear. 
        _Vectors2[index] = float3(0.0, 0.0, 0.0);
        _Vectors3[index] = float3(0.0, 0.0, 0.0);
        return;
    }
	
	// Depending on how the material works and if the trans. matrix needs to scale, NORMALIZE VECT HERE.
    if ((vect.x == 0.0) && (vect.y == 0.0))
    { // Guaranteeing that vect_2 isn't parallel with vect with 
        vect_2.x = 0.0;
        vect_2.y = -vect.z;
        vect_2.z = vect.y;
    }
    else
    {
        vect_2.x = vect.y;
        vect_2.y = -vect.x;
        vect_2.z = 0.0;
    }

	// Re-magnituding vect_2
    float vect_2_mag = sqrt(vect_2.x * vect_2.x + vect_2.y * vect_2.y + vect_2.z * vect_2.z);
    vect_2 *= (vect_mag / vect_2_mag);

	// Cross product!
    vect_3.x = vect.y * vect_2.z - vect.z * vect_2.y;
    vect_3.y = vect.z * vect_2.x - vect.x * vect_2.z;
    vect_3.z = vect.x * vect_2.y - vect.y * vect_2.x;

	// Re-magnituding vect_3
    float vect_3_mag = sqrt(vect_3.x * vect_3.x + vect_3.y * vect_3.y + vect_3.z * vect_3.z);
    vect_3 *= (vect_mag / vect_3_mag);
	
    _Vectors2[index] = vect_2;
    _Vectors3[index] = vect_3;
};


#define KERNEL_NAME(fieldName) \
    [numthreads(64, 1, 1)] \
    void fieldName##Field(uint3 id : SV_DispatchThreadID) { \
        fieldName field; \
        uint bufferSize; \
        uint stride; \
        _Positions.GetDimensions(bufferSize, stride); \
        if (id.x < bufferSize) { \
            FieldStrength(id.x, field); \
            CalcVectors23(id.x); \
        } \
    }

KERNEL_NAME(Outwards)
KERNEL_NAME(Swirl) 